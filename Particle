import bpy
import bmesh
import random
import math
import sys
from os.path import dirname,basename, join
from perlin_noise import PerlinNoise
import mathutils
import numpy as np
from mathutils import Vector

# Define the object name where you want to add vertices
object_name = "sim_object"  # Change this to your object's name
particles = []
noise = PerlinNoise(octaves=1   , seed=1)
particles_per_frame=1
receptor_objects=[]
#particle: [x,y,z,ID,random per particle,velx,vely,velz,alive]


def particles_update(particles,frame):
    global particles_per_frame
    global receptor_objects
    if(frame == 1):
        particles=generate_random_vectors(4000,0)
        receptor_objects=find_receptor_objects()
        print("receptors found: ",receptor_objects)
        

    else:
        randomness=0.02
        for particle in particles: 
            
            particle[0]+=(random.random() - 0.5)*randomness 
            particle[1]+=(random.random() - 0.5)*randomness 
            particle[2]+=(random.random() - 0.5)*randomness 
            
            particle[0]+=noise([particle[0]+particle[3]+frame/240, particle[0]+particle[3]+20])*0.08
            particle[1]+=noise([particle[1]+particle[3]+frame/240, particle[1]+particle[3]+40])*0.08
            particle[2]+=noise([particle[2]+particle[3]+frame/240, particle[2]+particle[3]+60])*0.08
            """
            particle[0]+=perlin_noise_1d(particle[0]+frame/240,particle[3])*0.04
            particle[1]+=perlin_noise_1d(particle[1]+frame/240,particle[3])*0.04
            #particle[2]+=perlin_noise_1d(particle[2]+frame/240,particle[3])*0.04
            """
        
        #check receptor collisions
        check_receptor_collision(receptor_objects,particles)
        
        #old way
        #check_particles_collision(particles)

        #new way
        cell_size=0.05
        check_particles_collision_with_grid(particles,cell_size=cell_size)
        
        print("particle count: ",len(particles))
        
        [particles.append(vec) for vec in generate_random_vectors(particles_per_frame,frame)]


    return particles


def check_particles_collision(particles):
    hit_distance = 0.01
    for particle_1 in particles:
        for particle_2 in particles:
            distance=math.sqrt((particle_1[0] - particle_2[0])**2 + (particle_1[1] - particle_2[1])**2 + (particle_1[2] - particle_2[2])**2)
            if(particle_1 != particle_2):
                if(distance<hit_distance):
                    try:
                        particles.remove(particle_1)
                    except:pass

def create_particle_grid(particles, cell_size):
    particle_grid = {}
    for particle in particles:
        grid_x = int(particle[0] / cell_size)
        grid_y = int(particle[1] / cell_size)
        grid_z = int(particle[2] / cell_size)
        cell_key = (grid_x, grid_y, grid_z)
        if cell_key not in particle_grid:
            particle_grid[cell_key] = []
        particle_grid[cell_key].append(particle)
    return particle_grid

def get_neighboring_cells(cell_key):
    neighboring_cells = []
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            for dz in [-1, 0, 1]:
                neighboring_cells.append((cell_key[0] + dx, cell_key[1] + dy, cell_key[2] + dz))
    return neighboring_cells

def check_particles_collision_with_grid(particles, cell_size=0.01):
    particle_grid = create_particle_grid(particles, cell_size)
    hit_distance = 0.02
    particles_to_remove = []

    for cell_key, cell_particles in particle_grid.items():
        for particle_1 in cell_particles:
            for neighboring_cell_key in get_neighboring_cells(cell_key):
                if neighboring_cell_key in particle_grid:
                    neighboring_cell_particles = particle_grid[neighboring_cell_key]
                    for particle_2 in neighboring_cell_particles:
                        if particle_1 != particle_2:
                            distance = math.sqrt((particle_1[0] - particle_2[0])**2 + (particle_1[1] - particle_2[1])**2 + (particle_1[2] - particle_2[2])**2)
                            if distance < hit_distance:
                                particles_to_remove.append(particle_1)

    for particle in particles_to_remove:
        try:
            particles.remove(particle)
        except:pass




def offset_vectors_to_outside(vector1, radius1, vector2, radius2):
    # Calculate the direction vector from vector2 to vector1
    direction = [vector1[0] - vector2[0], vector1[1] - vector2[1], vector1[2] - vector2[2]]

    # Calculate the distance between vector1 and vector2
    distance = math.sqrt(direction[0]**2 + direction[1]**2 + direction[2]**2)

    # Calculate the sum of the radii
    total_radius = radius1 + radius2

    # If the distance is less than the sum of the radii, there is a collision
    if distance < total_radius:
        # Calculate the offset to move vector1 to the outside of vector2
        offset_length = total_radius - distance

        # Normalize the direction vector
        if distance > 0:
            direction = [direction[0] / distance, direction[1] / distance, direction[2] / distance]

        # Calculate the new position for vector1
        new_vector1 = [vector1[0] + direction[0] * offset_length, vector1[1] + direction[1] * offset_length, vector1[2] + direction[2] * offset_length]

        return new_vector1

    # If there is no collision, return the original vector1
    return vector1
def check_receptor_collision(receptor_objects,particles):
    
    for receptor in receptor_objects:
        receptor_location=list(receptor.location)
        receptor_radius=receptor.scale[0]
        for particle in particles:
            particle_location = particle[0:3]
            particle_redius = 0.04
            distance=math.sqrt((particle_location[0] - receptor_location[0])**2 + (particle_location[1] - receptor_location[1])**2 + (particle_location[2] - receptor_location[2])**2)
            if(distance < particle_redius+receptor_radius):
                if(particle[4] > receptor["bounce_rate"]):#branch of killing the particle
                    particles.remove(particle)
                    receptor["kill_count"]+=1
                else:#branch of offsetting the particle
                    print("offset")
                    new_particle_loc = offset_vectors_to_outside(particle[0:3],0.04,receptor_location,receptor_radius)
                    particle[0:3]=new_particle_loc

def find_receptor_objects():
    receptor_objects = []

    # Iterate through all objects in the scene
    for obj in bpy.context.scene.objects:
        # Check if "receptor" is in the object's name (case insensitive)
        if "receptor" in obj.name.lower():
            receptor_objects.append(obj)
    
    return receptor_objects

def fade(t):
    return t * t * t * (t * (t * 6 - 15) + 10)

def lerp(t, a, b):
    return a + t * (b - a)

def grad(hash, x):
    h = hash & 15
    grad = 1 + (h & 7)
    if h & 8:
        grad = -grad
    return grad * x

def perlin_noise_1d(x, seed, period=512):
    p = np.arange(period, dtype=int)
    np.random.seed(seed)
    np.random.shuffle(p)
    p = np.append(p, p)

    x = x % period
    X = int(x) & (period - 1)
    x -= int(x)
    u = fade(x)

    return lerp(u, grad(p[X], x), grad(p[X + 1], x - 1))


def generate_random_vectors(size,seed):
    global particles
    random.seed(seed)
    #random_array = [[random.uniform(-1, 1) for _ in range(3)] for _ in range(size)]
    random_array=generate_random_points_in_sphere(0.5,size)
    for id_elem, elem in  enumerate(random_array):
        elem.append(id_elem+len(particles))
        elem.append(random.random())

    return random_array
def generate_random_points_in_sphere(radius, num_points):
    points = []
    for _ in range(num_points):
        # Generate random spherical coordinates
        theta = random.uniform(0, 2 * math.pi)
        phi = random.uniform(0, math.pi)
        r = radius * (random.random() ** (1/3))  # To ensure uniform distribution within the sphere

        # Convert spherical coordinates to Cartesian coordinates
        x = r * math.sin(phi) * math.cos(theta)
        y = r * math.sin(phi) * math.sin(theta)
        z = r * math.cos(phi)

        points.append([x, y, z])

    return points
def my_frame_change_handler(scene):
    # Get the object by name
    global particles
    obj = bpy.data.objects.get(object_name)
    frame = scene.frame_current
    print(f"Frame changed to {frame}")
    try:
        previous_frame
    except:
        previous_frame=0
    if obj is not None and obj.type == 'MESH' and previous_frame != frame :
        # Create a BMesh to manipulate the mesh data
        bm = bmesh.new()

        # Calculate the location where you want to add a vertex
        x = frame/100
        y = frame/100
        z = frame/100

        particles = particles_update(particles,frame)
        # Add a new vertex at the specified location
        for particle in particles:
            new_vert = bm.verts.new(tuple(particle[0:3]))

        # Update the geometry
        bm.to_mesh(obj.data)
        bm.free()
    
    previous_frame = frame


class particle:
    def __init__(self,x,y,z,ID):
        self.position=Vector((x,y,z))
        self.ID=ID
        self.velocity=Vector((0,0,0))

#restart simulation
bpy.context.scene.frame_current = 1
bpy.ops.screen.animation_play()

# Remove any existing frame change handlers with the same name before appending a new one
if my_frame_change_handler in bpy.app.handlers.frame_change_post:
    bpy.app.handlers.frame_change_post.remove(my_frame_change_handler)

#remove all post frame handler
for handler in bpy.app.handlers.frame_change_post:
    bpy.app.handlers.frame_change_post.remove(handler)

# Register the frame change handler to be called on every frame change
bpy.app.handlers.frame_change_post.append(my_frame_change_handler)
